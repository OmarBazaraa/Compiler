# Lex

## Structure of a Lex Specifcation
Lex specification file consists of three parts: the **definition** section, the **rules** section, and the **user subroutines** section.

```
... definition section ...
%%
... rules section ...
%%
... user subroutines section ...
```

#### 1. Definition Section
The definition section can include the literal block, definitions, internal table declarations, start conditions, and translations.

#### 2. Rules Section
The rules section contains pattern lines and C code.
A line that starts with whitespace, or material enclosed in `%{` and `%}` is C code.
A line that starts with anything else is a pattern line. 

Pattern lines contain a pattern (regular expression) followed by some whitespace and an action (C code) to execute when the input matches the pattern. If the C code is more than one statement or spans multiple lines, it must be enclosed in braces.

#### 3. User Subroutines Section
The contents of the user subroutines section is copied literally by lex to the C file.

This section typically includes routines called from the rules. If you redefine `input()`, `unput()`, `output()`, or `yywrap()`, the new versions or supporting subroutines might be here.

#### Literal Block
The literal block in the definition section is C code bracketed by the lines `%{` and `%}`.

```
%{
... C code and declarations ...
%}
```

The contents of the literal block are copied literally to the generated C source file near the beginning, before the beginning of `yylex()`. The literal block usually contains declarations of variables and functions used by code in the rules section, as well as `#include` lines for header files.

## Lex Useful Variables, Functions, and Macros

### Functions

- #### `yylex()`  
  The main lexer function auto-generated by lex.  
  `yylex()` won't return until it has processed the entire input, unless the actions contain explicit return statements.  
  It returns 0 as a signal to the parser that the input for the current parse is completed.

- #### `yywrap()`  
  When `yylex()` reaches the end of its input file, it calls `yywrap()`, which returns a value of 0 or 1.  
  If the value is 1, the program is done and there is no more input.  
  If the value is 0, on the other hand, the lexer assumes that `yywrap()` has opened another file for it to read, and continues to read from `yyin`.

- #### `yyrestart(file)`  
  Restarts `yyflex()` to its initial state, and begin reading from the begining of the given file.  
  
  **Note:** available in **_FLEX_** version only.

- #### `yyless(int)`  
  You can call `yyless(n)` from the code associated with a rule to push back all but the first **_n_** characters of the token. 

- #### `yymore()`  
  You can call `yymore()` from the code associated with a rule to tell lex to append the next token to this one.

- #### `input()`  
  Returns the next character from the input file.  
  Returns 0 when the lexers reaches end-of-file and there is no more input.  
  
  **Note:** not used in **_FLEX_** version.

- #### `unput()`  
  Puts a character back in the logical input stream.  
  
  **Note:** not used in **_FLEX_** version.

### Variables

- #### `yytext`  
  A character array that contains the text that matched the pattern.

- #### `yyleng`  
  An integer that holds the length of the matched text.

- #### `yylineno`  
  An integer that keeps track of the current line number.  
  
  **Note:** Some versions of lex define `yylineno` to contain this line number and automatically update it, but most do not.

- #### `yyin`  
  The input file that the lexer reads from. Defaults to `stdin`.

- #### `yyout`  
  The output file that the lexer writes to. Defaults to `stdout`.

### Macros

- #### `ECHO`  
  Prints the text that matched the pattern.

- #### `BEGIN`  
  Switches among start states.  
  You invoke it, usually in the action code for a pattern, as `BEGIN statename`;

- #### `REJECT`  
  If an action executes `REJECT`, lex conceptually puts back the text matched by the pattern and finds the next best match for it.
